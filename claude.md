# Claude Code 動作方針

## 基本方針

ユーザーからの質問には丁寧に回答しますが、**コードの編集・追加・削除等の変更は、ユーザーから明示的な指示があった場合のみ実行します。**

## 具体的な動作

### 質問への回答（常に実行）
- コードの説明や解説
- 技術的な質問への回答
- 既存コードの分析や理解
- アーキテクチャやデザインパターンの説明
- バグの原因調査や分析
- テストケースの説明
- **コードレビューと改善提案**（実装はしない）

### コード変更（明示的な指示があった場合のみ実行）
- ファイルの新規作成
- 既存コードの編集
- リファクタリング
- バグ修正の実装
- 新機能の追加
- テストコードの作成や変更

## 判断基準

以下のような表現があった場合は、コード変更を実行します：
- 「〜を修正して」「〜を追加して」「〜を実装して」
- 「〜を作成して」「〜を変更して」「〜を書いて」
- 「〜してください」（変更を伴う場合）

以下のような表現の場合は、回答のみを行います：
- 「〜について教えて」「〜を説明して」
- 「〜はどうなっている？」「〜はどこ？」
- 「〜を確認して」「〜を調べて」
- 「〜の原因は？」「〜はなぜ？」
- 「〜をレビューして」「〜について議論して」（提案のみ、実装はしない）

---

## プロアクティブな提案

以下のタイミングで、ユーザーに提案を行います（**必ず確認を取る**）：

### 1. コミットのタイミング提案
論理的な単位（機能追加、テスト追加、リファクタリング）で作業が完了したら：
- 「この変更をコミットしますか？」と提案
- 大きな変更の前にも「変更前の状態をコミットしておきますか？」と提案

### 2. タスク管理（TodoWrite）
複数ファイルにまたがる変更や、複数ステップが必要な作業では：
- 最初に TodoWrite でタスクを分解して提示
- 各ステップ完了時に TodoWrite で進捗を更新
- すべてのタスク完了時に確認

### 3. リファクタリング提案
コード追加・変更後、テストが全て通ったら：
- 「リファクタリングできる部分があります」と自動的に提案
- 重複コード、マジックナンバー、長いメソッドなどを指摘
- 実施するかどうかをユーザーに確認

**段階的リファクタリング**：
複数の改善点がある場合は、以下のように段階的に実施：
- **第1段階**: 機能的な修正（バグ修正、必須の変更、アーキテクチャ変更）
- **第2段階**: コード品質の改善（Optional、エラーハンドリング、イディオム統一）
- **第3段階**: ドキュメントの改善（Javadoc、コメント整理）
- 各段階でテストを実行し、安全性を確認
- 各段階で論理的な単位でコミット

**優先度の判断基準**：
- **必須（高）**: バグ、機能不全、セキュリティ問題
- **推奨（中）**: 保守性、テスタビリティ、拡張性の向上
- **任意（低）**: スタイル統一、ドキュメント改善

### 4. 設計議論の記録
重要な設計判断や技術的議論があった場合：
- コード内コメントまたは設計ドキュメントへの記録を提案
- 議論の結論を簡潔にまとめてコミットメッセージに含める
- 可能であれば `docs/design-notes/` ディレクトリにドキュメント作成

**design-notes に含めるべき内容**：
- **背景**: なぜこの変更が必要だったか（レビュー指摘、バグ、改善要求等）
- **実施した改善**: 具体的な変更内容と各判断理由
- **技術的な議論**: 設計上の選択肢と採用した理由、代替案の検討
- **テスト結果**: 変更前後のテスト実行結果
- **今後の課題**: 残された問題や将来の拡張ポイント
- **まとめ**: 変更のポイント、メリット、影響範囲、学び

**ファイル名形式**: `YYYY-MM-DD-topic-name.md`

**記録が推奨されるケース**：
- 複数の設計選択肢から1つを選んだ場合
- アーキテクチャの変更（DI導入、パターン適用等）
- 技術的な判断に議論があった場合
- 後から「なぜこうしたのか」が問われそうな変更

### 5. テスト駆動開発（TDD）
大きな変更や新機能の実装時：
- 「まず失敗するテストを確認しますか？」と提案
- Red → Green → Refactor のサイクルを明示的に
- 既存テストが影響を受ける場合は事前に確認

### 6. コードレビューと改善提案
コードレビューを依頼された場合：
- **優先度別に改善点を整理**（必須・推奨・任意）
- **各改善点の判断理由を説明**（なぜ必要か、メリット・デメリット）
- **代替案の検討**（可能な場合）
- **実施するかどうかをユーザーに確認**
- 承認後、段階的にリファクタリングを実施

---

## レビューと議論のプロセス

### レビュー依頼への対応
「レビューして」「議論してください」と言われた場合：

#### 1. 分析フェーズ
- コードを詳細に読み込む
- 関連するテスト、ドキュメント、design-notes も確認
- 改善点を特定し、優先度別に分類

#### 2. 提案フェーズ
- 改善点を「必須・推奨・任意」で分類
- 各改善点の判断理由を説明
  - なぜこれが問題なのか
  - 改善することのメリット
  - 改善しない場合のデメリット
- 可能な場合は代替案も提示
- **実装はせず、提案のみ行う**

#### 3. 実装フェーズ（ユーザーの承認後）
- 承認された改善を段階的に実施
  - 第1段階: 機能的な修正
  - 第2段階: コード品質の改善
  - 第3段階: ドキュメントの改善
- 各段階でテストを実行
- 論理的な単位でコミット

#### 4. 記録フェーズ
- 設計議論を design-notes に記録
- 判断理由と学びを明文化
- 今後の参考となる情報を整理

---

## コミット粒度の方針

### 論理的な単位での分割
複数の改善を行う場合、以下の単位でコミットを分割：

#### 1. 機能的な変更
- バグ修正
- 必須の変更
- アーキテクチャ変更（DI の導入、パターン適用等）
- Post-state 対応などの仕様変更

**例**: `refactor: CauseLineFinder に依存性注入（DI）を導入`

#### 2. コード品質の改善
- リファクタリング
- イディオムの統一（Optional、Stream API 等）
- エラーハンドリングの改善（ロガー導入等）
- 冗長なコードの削除

**例**: `refactor: CauseLineFinder のコード品質を改善`

#### 3. ドキュメントの改善
- Javadoc の追加・修正
- コメントの整理とスタイル統一
- README の更新
- インラインコメントの改善

**例**: `docs: CauseLineFinder のコメントとドキュメントを全面改善`

#### 4. 設計記録
- design-notes の作成
- 判断理由の文書化
- 技術的議論の記録

**例**: `docs: CauseLineFinder リファクタリングの設計議論を記録`

### 分割のメリット
- **変更の追跡が容易**: git log で何が変わったか一目瞭然
- **レビューがしやすい**: 各コミットの目的が明確
- **ロールバックが安全**: 問題発生時に特定の変更だけ戻せる
- **git history が読みやすい**: プロジェクトの進化を理解しやすい

### 分割の判断基準
- 1つのコミットで1つの目的
- コミットメッセージで変更の意図が明確に説明できる
- テストが通る単位で分割（ビルドが壊れない）
- 関連する変更はまとめる（例: DI 導入とフィールドの final 化）